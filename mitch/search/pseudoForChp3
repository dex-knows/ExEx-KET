Psuedocode for BSF
This is the same as the book but, I've tried to make it easier to understand
in context of python (or my basic understanding). When I use the term 
solution, it means I don't have a way of keeping track of the solution
so it is filler until I think of one.

function BFS(problem) returns solution or failure
  node = problem.GetStartState()
  if problem.isGoalState(node) then return solution(node)
  frontier=[node]
  explored=[]
  while !frontier.isEmpty()
    newNode=frontier.pop()
    explored.append(newNode)
    successors = newNode.getSuccessors()
    for successor in successors
      if successor.isNotIn(frontier or explored) then
        if problem.isGoalState(succesor) then return solution(successor)
        frontier.append(successor)
  return failure

Psuedocode for DFS
After much debate/discussion with Dex, I think we have hammered out the rough structure of DFS. The explored list is actually going to be of type explored, which is going to have properties location, direction, and parent. To keep track of the goal path, we came up with a helper method, makeSolution, which takes the explored lists and goes through the nodes on the goal path then goes back to get the directions of the goal path.

function DFS(problem) returns solution or failure
  node = problem.GetStartState()
  frontier=[node]
  explored=[]
  while len(frontier)!=0
    newNode=frontier.pop()
    explored.append(newNode)
    if problem.isGoalState(node): return makeSolution(explored)
    successors = newNode.getSuccessors()
    for successor in successors
      if successor.isNotIn(frontier or explored) then
        frontier.append(successor)
  return []

function makeSolution(explored) returns solution
  solution=[]
  parent = explored[0].parent()
  while len(explored)!=0:
    path = explored.pop()
    if path==parent:
      solution.push(path)
      parent=path.parent()
  return solution

Sadly, I got a little cocky and just wrote down "Dijstra Algorithm" for 
uniform cost instead of actually psuedocoding it. This is the basis for A* 
and the A* variants (obviously)
